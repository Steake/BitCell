//! Key management for trusted setup ceremony
//!
//! This module provides functionality for:
//! - Serializing and deserializing Groth16 proving and verification keys
//! - Loading ceremony-generated keys from disk
//! - Verifying key integrity
//!
//! # Security Note
//! 
//! The keys loaded by this module should ONLY be used after a proper
//! multi-party trusted setup ceremony has been conducted. Using keys
//! generated by `setup()` in production would compromise security.

use ark_groth16::{ProvingKey, VerifyingKey};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::path::Path;

/// Serialize a proving key to a file
///
/// # Arguments
/// * `pk` - The proving key to serialize
/// * `path` - Path where the key should be saved
///
/// # Returns
/// * `Ok(())` if serialization succeeds
/// * `Err` if file I/O or serialization fails
pub fn save_proving_key(
    pk: &ProvingKey<ark_bn254::Bn254>,
    path: impl AsRef<Path>,
) -> crate::Result<()> {
    let file = File::create(path.as_ref())
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to create file: {}", e)))?;
    let mut writer = BufWriter::new(file);
    
    pk.serialize_compressed(&mut writer)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to serialize proving key: {}", e)))?;
    
    writer.flush()
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to flush writer: {}", e)))?;
    
    Ok(())
}

/// Deserialize a proving key from a file
///
/// # Arguments
/// * `path` - Path to the serialized proving key
///
/// # Returns
/// * `Ok(ProvingKey)` if deserialization succeeds
/// * `Err` if file I/O or deserialization fails
pub fn load_proving_key(
    path: impl AsRef<Path>,
) -> crate::Result<ProvingKey<ark_bn254::Bn254>> {
    let file = File::open(path.as_ref())
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to open file: {}", e)))?;
    let mut reader = BufReader::new(file);
    
    ProvingKey::<ark_bn254::Bn254>::deserialize_compressed(&mut reader)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to deserialize proving key: {}", e)))
}

/// Serialize a verification key to a file
///
/// # Arguments
/// * `vk` - The verification key to serialize
/// * `path` - Path where the key should be saved
///
/// # Returns
/// * `Ok(())` if serialization succeeds
/// * `Err` if file I/O or serialization fails
pub fn save_verification_key(
    vk: &VerifyingKey<ark_bn254::Bn254>,
    path: impl AsRef<Path>,
) -> crate::Result<()> {
    let file = File::create(path.as_ref())
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to create file: {}", e)))?;
    let mut writer = BufWriter::new(file);
    
    vk.serialize_compressed(&mut writer)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to serialize verification key: {}", e)))?;
    
    writer.flush()
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to flush writer: {}", e)))?;
    
    Ok(())
}

/// Deserialize a verification key from a file
///
/// # Arguments
/// * `path` - Path to the serialized verification key
///
/// # Returns
/// * `Ok(VerifyingKey)` if deserialization succeeds
/// * `Err` if file I/O or deserialization fails
pub fn load_verification_key(
    path: impl AsRef<Path>,
) -> crate::Result<VerifyingKey<ark_bn254::Bn254>> {
    let file = File::open(path.as_ref())
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to open file: {}", e)))?;
    let mut reader = BufReader::new(file);
    
    VerifyingKey::<ark_bn254::Bn254>::deserialize_compressed(&mut reader)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to deserialize verification key: {}", e)))
}

/// Compute a SHA-256 hash of a proving key for verification
///
/// This can be used to verify key integrity and ensure all participants
/// are using the same keys from the ceremony.
pub fn hash_proving_key(pk: &ProvingKey<ark_bn254::Bn254>) -> crate::Result<String> {
    use sha2::{Sha256, Digest};
    
    let mut hasher = Sha256::new();
    let mut bytes = Vec::new();
    pk.serialize_compressed(&mut bytes)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to serialize for hashing: {}", e)))?;
    
    hasher.update(&bytes);
    let result = hasher.finalize();
    Ok(format!("{:x}", result))
}

/// Compute a SHA-256 hash of a verification key for verification
///
/// This can be used to verify key integrity and ensure all participants
/// are using the same keys from the ceremony.
pub fn hash_verification_key(vk: &VerifyingKey<ark_bn254::Bn254>) -> crate::Result<String> {
    use sha2::{Sha256, Digest};
    
    let mut hasher = Sha256::new();
    let mut bytes = Vec::new();
    vk.serialize_compressed(&mut bytes)
        .map_err(|e| crate::Error::KeyManagement(format!("Failed to serialize for hashing: {}", e)))?;
    
    hasher.update(&bytes);
    let result = hasher.finalize();
    Ok(format!("{:x}", result))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::BattleCircuit;
    use std::env;

    #[test]
    fn test_save_and_load_proving_key() {
        // Generate test keys
        let (pk, _vk) = BattleCircuit::setup().expect("Setup should succeed");
        
        // Create temp file
        let temp_dir = env::temp_dir();
        let pk_path = temp_dir.join("test_proving_key.bin");
        
        // Save
        save_proving_key(&pk, &pk_path).expect("Save should succeed");
        
        // Load
        let loaded_pk = load_proving_key(&pk_path).expect("Load should succeed");
        
        // Verify they produce the same hash
        let original_hash = hash_proving_key(&pk).expect("Hash should succeed");
        let loaded_hash = hash_proving_key(&loaded_pk).expect("Hash should succeed");
        assert_eq!(original_hash, loaded_hash);
        
        // Cleanup
        std::fs::remove_file(pk_path).ok();
    }

    #[test]
    fn test_save_and_load_verification_key() {
        // Generate test keys
        let (_pk, vk) = BattleCircuit::setup().expect("Setup should succeed");
        
        // Create temp file
        let temp_dir = env::temp_dir();
        let vk_path = temp_dir.join("test_verification_key.bin");
        
        // Save
        save_verification_key(&vk, &vk_path).expect("Save should succeed");
        
        // Load
        let loaded_vk = load_verification_key(&vk_path).expect("Load should succeed");
        
        // Verify they produce the same hash
        let original_hash = hash_verification_key(&vk).expect("Hash should succeed");
        let loaded_hash = hash_verification_key(&loaded_vk).expect("Hash should succeed");
        assert_eq!(original_hash, loaded_hash);
        
        // Cleanup
        std::fs::remove_file(vk_path).ok();
    }

    #[test]
    fn test_key_hashing() {
        let (pk, vk) = BattleCircuit::setup().expect("Setup should succeed");
        
        // Hash multiple times and ensure consistency
        let hash1 = hash_proving_key(&pk).expect("Hash should succeed");
        let hash2 = hash_proving_key(&pk).expect("Hash should succeed");
        assert_eq!(hash1, hash2);
        
        let vk_hash1 = hash_verification_key(&vk).expect("Hash should succeed");
        let vk_hash2 = hash_verification_key(&vk).expect("Hash should succeed");
        assert_eq!(vk_hash1, vk_hash2);
        
        // Ensure hashes are valid hex strings
        assert_eq!(hash1.len(), 64); // SHA-256 produces 32 bytes = 64 hex chars
        assert_eq!(vk_hash1.len(), 64);
    }
}
